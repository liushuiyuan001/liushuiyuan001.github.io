import{_ as s,o as a,c as n,O as l}from"./chunks/framework.1156b012.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/bbj.md","filePath":"interview/bbj.md"}'),e={name:"interview/bbj.md"},t=l(`<br><ol><li>vue和react的区别以及diff算法的差异</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight has-diff"><code><span class="line"><span style="color:#A6ACCD;">vue中的diff是采用双端比较法，用新旧节点的开始和结束下标进行对比</span></span>
<span class="line"><span style="color:#A6ACCD;">react中的diff是采用顺序比较，用新旧节点的开始下标进行对比</span></span></code></pre></div><ol start="3"><li><p>小程序的授权过程</p></li><li><p>怎样在对forEach中断</p></li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> 效果只能相当于 continue</span></span>
<span class="line"><span style="color:#A6ACCD;">可以用 </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#A6ACCD;"> 中断，外部 </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> 捕获</span></span>
<span class="line"><span style="color:#A6ACCD;">最好用for循环即可</span></span></code></pre></div><ol start="5"><li>img图片403错误怎么解决</li></ol><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">&lt;!-- 隐藏发送请求时请求头表示来源的referrer字段。 --&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">meta</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">referrer</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">content</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">no-referrer</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><ol start="4"><li>数组中查过一半的数字，要求On时间复杂度 O1 空间复杂度</li></ol><p><a href="https://www.cnblogs.com/hirampeng/p/9613336.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/hirampeng/p/9613336.html</a></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">1.排序  nlogn 然后找出中间位置的数字</span></span>
<span class="line"><span style="color:#A6ACCD;">2.定义map 遍历数组然后统计次数key为数子 value为次数  空间复杂度 n 时间复杂 n</span></span>
<span class="line"><span style="color:#A6ACCD;">3.定义快慢指针</span></span>
<span class="line"><span style="color:#A6ACCD;">如果相邻元素不同则同时删除 如果不同则保留，最后剩下的一个或两个则是超过一般的数字</span></span>
<span class="line"><span style="color:#A6ACCD;">但是比如 [5，5，5，5，1] 则无法实现</span></span>
<span class="line"><span style="color:#A6ACCD;">4.利用线性特点，num为遍历到数组 count 则为出现的次数</span></span>
<span class="line"><span style="color:#A6ACCD;">	1.如果下一个数字和我们之前保存的数字相同，则次数加1；</span></span>
<span class="line"><span style="color:#A6ACCD;">	2.如果下一个数字和我们之前保存的数字不同，则次数减1，如果减1之后为0则我们需要保存下一个数字，并把次数重新设为1。</span></span>
<span class="line"><span style="color:#A6ACCD;">	最后返回的num即为超过一半的数字</span></span></code></pre></div>`,10),p=[t];function o(c,r,i,y,D,C){return a(),n("div",null,p)}const h=s(e,[["render",o]]);export{d as __pageData,h as default};
